## 图片懒加载

图片懒加载也叫延迟加载，只加载当前屏幕的图片，可视区域外的图片不会进行加载，只有当屏幕滚动的时候才加载

1. 特点：

- 提高网页加载速度
- 减少后台服务器压力
- 提升用户体验

2. 原理

- 将图片地址存储到 data-xxx 属性上
- 判断图片是否在可视区域
- 如果在，就设置图片 src
- 绑定 scroll 监听事件

## 防抖和节流

1. 防抖

防抖函数将多次触发的函数合并成一次去执行，并在指定的时间间隔后执行一次。通常在处理输入框、滚动等事件时使用，避免频繁触发事件导致页面卡顿等问题。
函数在 n 秒后再执行，如果 n 秒内被触发，重新计时，保证最后一次触发事件 n 秒后才执行。

应用场景：

- 输入框搜索
- 表单提交按钮
- 文本器保存

>示例

```js
/**
 * @description  防抖
 * @param { fn}执行函数
 * @param {await}等待时间
 * @param {immediate}是否立即执行
 * @return {Function}
 */
const debounce = (fn, await = 500, immediate = false) => {
  let timer = null;
  return function () {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    if (immediate) {
      fn && fn.call(this, arguments)
      timer = setTimeout(() => {
        timer = null
      }, await)
    }
    else {
      timer = setTimeout(() => {
        fn.call(this, arguments)
      }, await);
    }
  }
}
```

2. 节流
函数在规定时间内只会执行一次，如果一段时间内被多次触发，则以第一次触发的时间为准。

>示例

```js
/**

- @description 节流
- @param {fn} 执行函数
- @param {await} 等待时间
- @reference
 */

const throttle = (fn, await = 500) => {
  let timer = null;
  return function () {
    if (timer) {
      return;
    }
    timer = setTimeout(() => {
      fn.call(this, arguments);
      timer = null;
    }, await);
  }
}
```

## 首屏加载速度慢

- **JavaScript文件过大**：SPA通常有很多 JavaScript  文件，如果这些文件的大小过大或加载速度慢，就会导致首屏加载缓慢。可以通过代码分割和打包、使用CDN等方式来优化加载速度。
- **数据请求过多或数据请求太慢**：SPA通过 AJAX 或 Fetch 等方式从后端获取数据，如果数据请求过多或数据请求太慢，也会导致首屏加载缓慢。可以通过减少数据请求、使用数据缓存、优化数据接口等方式来优化数据请求速度。
- **大量图片加载慢**：如果首屏需要加载大量图片，而这些图片大小过大或加载速度慢，也会导致首屏加载缓慢。可以通过图片压缩、使用图片懒加载等方式来优化图片加载速度。
- **过多的渲染和重绘操作**：如果在首屏加载时进行大量的渲染和重绘操作，也会导致首屏加载缓慢。可以通过尽可能少的DOM操作、使用CSS3动画代替JS动画等方式来优化渲染和重绘操作。
- **网络问题**：网络问题也会影响SPA首屏加载速度，比如网络延迟、丢包等。可以通过使用CDN、使用HTTP/2等方式来优化网络问题。

## 首屏加载优化

1. **代码拆分（Code Splitting）**：将应用程序的代码拆分成多个小块，按需加载。这可以减少初始加载时间，因为只有当前页面所需的代码会被加载，而不是一次性加载整个应用程序。

2. **路由懒加载**：如果您的SPA使用路由来管理页面切换，可以使用路由懒加载技术。这意味着每个路由对应的组件会在首次访问时才被加载，而不是在应用启动时加载所有路由组件。

3. **预加载**：预加载技术可以在后台加载将来可能需要的资源，以减少用户在导航到新页面时的加载时间。您可以使用`<link rel="preload">`标签或使用Webpack等构建工具的预加载插件。

4. **缓存**：合理使用浏览器缓存机制，将静态资源缓存到用户的本地存储中，以便在下次访问时可以更快地加载。

5. **图片优化**：优化图像以减小文件大小，使用适当的图像格式（如WebP），并应用懒加载以延迟图像的加载。

6. **压缩和缩小JavaScript和CSS文件**：通过使用压缩工具（例如UglifyJS和Terser）来减小JavaScript文件的大小，以及通过使用CSS压缩工具来减小CSS文件的大小，可以减少加载时间。

7. **服务端渲染（Server-Side Rendering，SSR）**：考虑在SPA中使用SSR，以便服务器可以在发送HTML之前渲染页面内容，减少客户端的初始加载时间。

8. **懒加载资源**：将一些不是首屏必需的资源（例如广告、分析脚本等）进行懒加载，以确保首屏加载速度更快。

9. **移除不必要的依赖**：检查您的项目依赖项，确保只加载和使用必需的库和组件。

10. **优化HTTP请求**：减少HTTP请求的数量，合并文件，使用HTTP/2等技术来优化资源加载。

11. **减少DOM操作**：尽量减少在首屏加载期间的DOM操作，因为DOM操作可能会导致页面重新渲染。

12. **代码优化**：优化JavaScript代码，避免不必要的循环和计算，以提高代码执行性能。

13. **性能监控**：使用性能监控工具来识别潜在的性能瓶颈，并定期进行性能分析和优化。

## 为什么要做性能优化

性能优化是为了提高网页的加载速度和相应速度，给用户带来更好的体验和用户满意度，同时还能减少服务器的负载压力，以此来提升程序的稳定性，具体有以下几个因素：

- 提高用户体验
- 增加页面访问量
- 提高搜索引擎排名
- 减少服务器压力
- 节约成本
- 提高用户留存率

## 性能优化方式

1. **压缩和缩小资源**：
   - 使用压缩工具（如UglifyJS和Terser）来减小JavaScript文件的大小。
   - 使用CSS压缩工具（如CSSNano）来减小CSS文件的大小。
   - 压缩图像以减小文件大小，使用适当的图像格式，例如WebP。

2. **减少HTTP请求**：
   - 合并多个CSS和JavaScript文件，减少文件数量。
   - 使用CSS雪碧图（CSS sprites）来合并小图标和背景图片。
   - 考虑使用字体图标代替图像图标，减少图像请求。

3. **浏览器缓存**：
   - 设置适当的缓存头（Cache Headers）来充分利用浏览器缓存。
   - 使用版本号或哈希值来确保浏览器在资源更新时获取新版本。

4. **使用CDN（内容分发网络）**：
   - 使用CDN分发静态资源，将资源提供给用户更接近他们的地理位置，从而减少加载时间。

5. **延迟加载**：
   - 使用懒加载技术，延迟加载页面上不是首次可见的内容，如图片、视频和部分JavaScript。

6. **异步加载资源**：
   - 使用`async`和`defer`属性来异步加载JavaScript文件，以避免阻塞页面渲染。

7. **优化图片**：
   - 使用现代图像格式，如WebP，以提高图像加载性能。
   - 为图像指定适当的尺寸，并使用响应式图像技术。

8. **使用字体优化**：
   - 选择合适的字体，避免使用过多的自定义字体。
   - 使用字体子集，只包含页面所需的字符，以减小字体文件大小。

9. **服务端渲染（Server-Side Rendering，SSR）**：
   - 对于需要SEO优化和更快的首屏加载速度的应用程序，考虑使用SSR。

10. **代码分割**：
    - 将代码拆分成小块，并按需加载，以减小初始加载时间。

11. **性能监控**：
    - 使用性能监控工具来识别潜在的性能问题，定期进行性能分析和优化。

12. **减少第三方依赖**：
    - 最小化使用第三方库和插件，因为它们可能增加页面加载时间。

13. **提前加载重要资源**：
    - 使用`<link rel="preload">`标签来提前加载关键资源，以减少加载时间。

14. **优化DOM操作**：
    - 减少频繁的DOM操作，因为它们可能导致页面重排（reflow）和重绘（repaint）。

15. **响应式设计**：
    - 使用响应式设计来确保网站在不同设备和屏幕尺寸上都有良好的性能和用户体验。

16. **减小JavaScript的运行时间**：
    - 优化JavaScript代码，避免不必要的循环和计算。
    - 使用Web Workers来将一些任务移到后台线程以提高性能。

17. **使用现代Web技术**：
    - 使用HTTP/2协议以减少多个资源请求的开销。
    - 使用新的浏览器API，如Service Workers，以实现离线访问和缓存。
